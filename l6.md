---
layout: default
---

По мере создания класса в основной программе проверяйте корректность добавляемых 
элементов. В квадратных скобках указано, сколько баллов вы получаете за
выполнение работы с начала и до данного пункта включительно.

## Класс `cstring_vector` 

### Поля класса [1 балл]

Создайте класс `cstring_vector` с полями:

* `data` типа указатель на C-строку — для хранения массива C-строк — `char **`;
*   `size` типа `size_t` — текущий (логический) размер массива строк data («заполненность»);
*   `capacity` типа `size_t` — текущая ёмкость (физический размер массива data — размер выделенной для него памяти).

Стоит иметь ввиду, что всегда должен быть выполнен инвариант класса:
`size <= capacity`.

Также объявите и инициализируйте две статические константы класса: 

* `MIN_CAPACITY = 5` (минимальная ёмкость) и 
* `CAPACITY_FACTOR = 2` (множитель для увеличения ёмкости при её нехватке). 

Создайте геттер для поля `size`.

### Конструкторы класса [1.5 балла]

В дальнейшем будет удобно использовать закрытую функцию-член:

    void init_from_cstr_array(char ** cstr_array, size_t size);
    
для инициализации `data` с помощью массива `cstr_array`, содержащего 
`size` C-строк. Алгоритм:

*   выделяется память для массива `data` размера `size * CAPACITY_FACTOR`;
*   в цикле для каждого элемента `data` выделяется память, достаточная для хранения 
    соответствующей строки из `cstr_array` (нужно узнать её длину —
    [`strlen`](http://cplusplus.com/reference/clibrary/cstring/strlen/) — и не 
    забыть про дополнительное место для завершающего нулевого байта) и копируется 
    эта строка
    ([`strcpy`](http://cplusplus.com/reference/clibrary/cstring/strcpy/)).

В этой же функции задайте нужные значения для полей класса: `size` и `capacity`.

Определите следующие конструкторы `cstring_vector`:

1.  Без параметров, который выделяет для массива `data` память под `MIN_CAPACITY`
    C-строк, инициализирует `size` нулём и `capacity` значением `MIN_CAPACITY`.
2.  С двумя параметрами `char ** cstr_array` и `size_t size`, для инициализации 
    из массива C-строк; используйте `init_from_cstr_array`.
3.  С двумя параметрами `char const ** cstr_array` и `size_t size`, для 
    инициализации из массива константных C-строк; используйте `init_from_cstr_array` 
    вместе со снятием константности с C-строк с помощью оператора 
    `const_cast<?>(cstr_array)`, вместо ? должен стоять тип, к которому приводится
    `cstr_array` — подумайте, какой это тип.
4.  С одним параметром `std::vector<std::string>`. При копировании `std::string`
    в C-строки удобно пользоваться функцией-членом `string::c_str()` и
    стандартной функцией копирования C-строк `strcpy`.

Проверьте работу всех конструкторов. Конструктор из константных C-строк должен
проверяться с помощью переменной

    char const * consts_cstr_arr[] = {"Anything", "you", "like"};

Помните, что вариант без квалификатора const в таком объявлении потенциально
ошибочен (компилятор GCC, например, в этом случае выдаст предупреждение; 
компилятор Visual C++ в Debug-сборке сгенерирует код таким образом, что при 
попытке модификации любой строки массива будет выдана ошибка времени 
выполнения; проверьте это на вашем компиляторе).

### Деструкция и копирование [2 балла]

Определите деструктор класса `cstring_vector`, который сначала в цикле 
освобождает память от каждой C-строки в массиве `data`, а затем освобождает 
память самого массива `data`. Напомним, что операция освобождения памяти 
из-под любого массива (как одной C-строки, так и массива `data`):

    delete [] p;

где `p` — указатель на соответствующий массив.

Определите следующие основные функции класса:

* конструктор копий (с использованием функции `init_from_cstr_array`);
* закрытую функцию `swap`, которая меняет местами значения всех полей
  `this` и аргумента `other`; 
* операцию копирующего присваивания с помощью трюка 
  [copy-and-swap](http://razykov.github.io/PL_Lections_2014-2015/lecture/12.html#copy_and_swap_idiom).
* move-конструктор копии, в котором просто копируется значение всех полей из 
  аргумента `other` в поля `this`.
  
**Замечание.** Обратите внимание, что идиома copy-and-swap освобождает от 
необходимости реализовывать move-операцию копирующего присваивания: аргумент
имеющейся `operator=` будет конструироваться нужным конструктором копии (обычным
или move-) в зависимости от правой части операции `=` при её использовании. 

### Доступ к строкам в массиве [3 балла]

1.  Определите операцию обращения по индексу, возвращающую соответствующий 
    элемент массива `data`, то есть указатель на `char`. Добавьте константную 
    версию этой операции, возвращающую указатель на константу типа `char`. 
    Вспомните, что в классе `my_vector`, продемонстрированном на лекции, 
    возвращалась ссылка на хранимый объект массива. В комментариях к этой паре 
    функций перечислите все следствия такого отличия (возможность менять строки:
    их адреса, их длину, их отдельные символы).

2.  Реализуйте операцию `push_back`, которая добавляет копию полученной C-строки 
    в вектор. Если размер вектора достиг его ёмкости, необходимо перераспределить 
    память, для этого следует завести отдельную закрытую функцию-член `reallocate`,
    вот её алгоритм:
    
    * выделяется новый динамический массив указателей на `char` (`new_data`), 
      размер которого в `CAPACITY_FACTOR` раз больше текущего размера,
    * первые `size` элементов массива `new_data` заполняются значениями из 
      массива `data` (использовать 
      [`std::copy`](http://www.cplusplus.com/reference/algorithm/copy/),
      который неоднократно демонстрировался на лекциях), 
    * массив `data` удаляется, 
    * переменной `data` присваивается значение `new_data`. 
    * задаётся новое значение поля `capacity`.
    
    Алгоритм для `push_back`:

    * убедиться, что памяти в `data` достаточно (при необходимости вызвать 
    `reallocate`);
    * в конец `data` (`size`-ый элемент) записывается копия полученной в параметре
    `push_back` строки, это делается в два шага: выделение памяти (`new`) и 
    копирование (`strcpy`);
    * увеличить `size` на единицу.

### Дополнительные задачи

1.  Реализуйте функции-члены `insert(i, str)` и `erase(i)` для вставки/удаления 
    C-строк в/из массива. В случае некорректного индекса, выбрасывайте исключение 
    `std::out_of_range` (требуется включить стандартный заголовочный файл `stdexcept`).

2.  Реализуйте перегрузку операций сравнения на равенство и на неравенство 
    объектов класса `cstring_vector`.

3.  Перегрузите операции вывода в поток и чтения из потока вектора C-строк. 
    Ввод должен продолжаться до тех пор, пока не будет введена пустая строка. 
    Продемонстрируйте их работу для строковых потоков.

4.  Реализуйте функцию-член `sort`, которая сортирует строки массива
    [лексикографически](http://ru.wikipedia.org/wiki/%D0%9B%D0%B5%D0%BA%D1%81%D0%B8%D0%BA%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA)
    с помощью стандартной функции `qsort`.
