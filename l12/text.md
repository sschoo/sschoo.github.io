# Лекция 12

## Какие функции компилятор генерирует молча

До сих пор мы определили поля, конструктор и деструктор класса `myvector`.
Объекты этого класса уже можно создавать в программе, при этом каждый раз по
окончании времени жизни объекта динамическая память, выделенная ранее, будет
освобождаться.

Однако при копировании вектора возникает **ошибка**.

    double free or corruption

Ошибка вызвана следующей проблемой в нашем коде: 

> два объекта владеют одним ресурсом.

Нарисуем происходящее на стеке и в динамической памяти… Как такое получилось?
Комиплятор **молча** генерирует следующие три функции, если они не были определены:

* `~myvector()` — деструктор,
* `myvector(myvector const &)` — конструктор копии (copy constructor),
* `operator=(myvector const &)` — операцию копирующего присваивания
    (copy assignment operator).

Кроме того, если самому не определить ни одного конструктора, он сгененирует
и _конструктор по умолчанию_.

То есть определение

    class Empty {};

эквивалентно

    class Empty {
    public:
      Empty() {}
      Empty(Empty & const) {}
      Empty & operator(Empty & const) {}
      ~Empty() {}
    };
    
Что делает каждая из генерируемых функций?

* _Конструктор по умолчанию_ это сгенерированный компилятором конструктор без
  параметров, который вызывает для всех классовых членов (членов, типы которых
  определены с помощью `class` или `struct`) конструкторы без 
  параметров. Традиционная ошибка с вызовом ктора без аргументов:
  
        int main()
        {
            myvector myv(); // ошибка! скобки следует убрать
        }

* _Конструктор копии_  (соответственно, _операция копирующего присваивания_) создаёт 
  копии всех членов с помощью их конструкторов копий (соответственно, `operator=`).

* _Деструктор_ вызывает деструкторы всех классовых членов.

Вернёмся к нашей проблеме.

> **«Правило трёх»** гласит: если вы определили одну перечисленных вначале трёх
> функций-членов то вы, вероятно, захотите определить и остальные три.

Определим оставшиеся функции-члены.

## Конструктор копии (copy ctor, копиктор, КК)

Конструктор копии класса `T` это функция-член

    T::T(T const & other) { /* … */ }

(Префикс `T::` нужен, если функция-член, лишь объявленная в классе, определяется
вне его.)

### Три ситуации, когда вызывается КК

**Первая.**

    myvector myv2 = myv1;

Вообще-то такая запись только затрудняет понимание (путает с `operator=`) 
и лучше писать

    myvector myv2(myv1);

Но и первый вариант часто используют.

**Вторая.**

    void f(myvector mv) { /* … */ }
    
То есть при передаче параметра функции по значению. Учитывая, что копирование 
объекта может быть медленным, передавать объект по значению не надо почти никогда,
а надо по ссылке, возможно константной.

Типичная ошибка:

    myvector(myvector other) { /* … */ } 
    
Однако копилятор GCC скажет на такое:

> error: invalid constructor; you probably meant ‘myvector (const myvector&)’

**Третья.**

    myvector g() { /* … */ }

То есть случай возврата по значению. Копирование объекта из кадра стека `g` 
(аргумент `return`) в кадр стека вызывающей функции происходит с помощью КК. 

Пример:

    int main()
    {
        myvector myv = g();
    }

Вопрос сколько КК тут вызывается? Ответ: два, потому что имеет первую и третью 
ситуацию. Однако все современные копиляторы смогут соптимизировать такой
простой случай, это называется **Return Value Optimization**, и не вызовется ни 
одного.

## Категории значений и move-семантика (C++11)

В C++ выделяют две большие категории значений: леводопустимые (lvalue) и
праводопустимые (rvalue). Примеры.

    // lvalues:
    //
    int i = 42;
    i = 43; // ok, i is an lvalue
    int* p = &i; // ok, i is an lvalue
    int& foo();
    foo() = 42; // ok, foo() is an lvalue
    int* p1 = &foo(); // ok, foo() is an lvalue

    // rvalues:
    //
    int foobar();
    int j = 0;
    j = foobar(); // ok, foobar() is an rvalue
    int* p2 = &foobar(); // error, cannot take the address of an rvalue
    j = 42; // ok, 42 is an rvalue

Давно подмечено, что

    myvector myv = g();

может нести ненужные затраты по сравнению с

    myvector myv2 = myv1;

так как `myv1` может использоваться далее после копирования, а вот объект `g()`
нет. Для того, чтобы иметь возможность различить два этих случая в C++11 ввели
новый тип: ссылки на праводопустимые выражения, rvalue references. Опишем 
конструктор копии из праводопустимого выражения для нашего типа.

    myvector(myvector && other):
        size(other.size), data(other.data), name(other.name)
    {
        other.data = nullptr;
    }
