---
layout: default
---

Создайте новый проект, добавьте в него решение к [задачам 
занятия 5 “Files over RSA”](https://yadi.sk/d/2tSlqaI8cqfNZ). Для работы вам 
также понадобятся файлы NTL

* [ntl.lib](https://yadi.sk/d/oPN-ZoJVcqez2)
* [NTL-headers.zip](https://yadi.sk/d/HXvsu0Aocqeys)

Закомментируйте в классах файлов 
дружественные потоковые операции: они пригодятся для воспоминаний, но мы будем 
реализовывать их заново.

## Часть 1. Оптимизированная версия чтения/записи `int` [1 балл]

Определите в классах файлов функции-члены (не друзья) `operator<</>>`
(`<<` в `ofile` и `>>` в `ifile`) для записи или чтения `int` соответственно
пока с пустыми телами.

Рассмотрим сперва алгоритм записи. Как было указано в мотивации, при вызове
`operator<<(int)` мы будем помещать полученный `int` в буфер до тех пор, пока в
нём есть место. Буфер должен иметь размер, соответствующий параметрам 
криптосистемы на данном ключе (`buf_size`). У нас уже имеется
такой буфер: поле `buf`. Раньше он использовался только для промежуточной записи 
туда шифрограммы, но теперь мы будем накапливать в нём ещё и исходные 
«сообщения» (пока только `int`). Оказывается, что эти две цели никак не 
конфликтуют.

Для контроля заполненности буфера данными, которые предназначены для записи в 
файл введём в класс `rsaed_ofile` дополнительное поле: `buf_occupied` целого
типа.  Его следует инициализировать нулём в списке инициализации конструктора
класса.

Реализуем простейший алгоритм: переданное число в цикле побайтово записывается 
в буфер по индексу `buf_occupied`, этот индекс увеличивается на каждом шаге 
цикла. Если `buf_occupied` в ходе этого цикла стал равен `buf_size`, то пришло
время сбросить накопленные данные в файл, предварительно зашифровав их. При
этом `buf_occupied` устанавливается в 0. Ниже дан пример реализации этого алгоритма.

    class rsaed_ofile {
        // ...

        rsaed_ofile & operator<<(int m)
        {
            write_n_bytes(&m, sizeof(int));
            return *this;
        }

    private:

        void write_n_bytes(void * p, int n)
        {
            auto q = static_cast<unsigned char *>(p);
            for (int i = 0; i < n; ++i)
            {
                if (buf_occupied == buf_size)
                    write_buffer();
                buf[buf_occupied++] = *q++;
            }
        }

        void write_buffer()
        {
            ZZ m = NTL::ZZFromBytes(buf, buf_size);
            ZZ mrca = PowerMod(m, pub_key.e, pub_key.n);
            NTL::BytesFromZZ(buf, mrca, buf_size);
            fwrite(buf, 1, buf_size, file);
            buf_occupied = 0;
        }

Для завершения реализации записи следует учесть ещё одну деталь: когда объект
класса разрушается, следует сбросить всё, что есть в буфере в файле:

    ~rsaed_ofile()
    {
        if (buf_occupied > 0)
            write_buffer();
        fclose(file);
        delete [] buf;
    }

Ваша **задача** состоит в реализации операции чтения во втором классе
(`rsaed_ifile`) аналогично (с зеркальным отображением).

Указания.

1. Для поля, обозначающего количество считанных 
из буфера байт, рекомендуется использовать имя `buf_consumed` (вместо 
`buf_occupied`, которое использовалось выше). 

2. В конструкторе поле `buf_consumed` нужно не
обнулять, а делать равным `buf_size`, так как до первого чтения у нас нет в 
буфере никаких разумных данных.

3. Вспомогательные функции следует называть `read*`, а не `write*` (как выше).

4. Дополнительных действий в деструкторе (как выше) не требуется.

5. Реализация `read_buffer` отличается от `write_buffer` точно так же, как
   в занятии 5 отличались операции `<<` и `>>`, можете ещё раз взглянуть на них.

### Проверка 

С основной программе запишите два целых числа в файл, прочитайте два числа из 
него же и убедитесь (с помощью `assert`), что значения правильные. Не забудьте
поместить объект файла на запись в отдельный блок, чтобы его деструктор сработал 
раньше, чем файл будет открыт на чтение.

## Часть 2. Чтение и запись любых POD-типов [1 балл]

Схема, которая реализована в части 1, подходит для любых «простых типов»: 
`double`, `char`, простейших `struct`. Преобразуем это решение в шаблон. В 
данном случае, это шаблон функции-члена класса. При этом сами классы файлов
остаются обыкновенными (нешаблонными).

Превратите `operator<<(int)` и `operator<<(int &)` в шаблоны. При этом 
параметры шаблона уже всегда передаются по ссылке (на случай передачи больших
`struct`), так что заголовок шаблона операции `<<` будет выглядеть так:

    template<typename T>
    rsaed_ofile & operator<<(T const & t)

Преобразуйте операцию `>>` в шаблон самостоятельно. В основной программе 
проверьте, что вы можете записать и прочитать два значения типа `double`.

### Ограничение для типов, с которыми можно инстанцировать шаблон

Данная схема чтения-записи не будет работать для «сложных» типов, например, для 
C-строк она бессмысленна: C-строка задаётся одним указателем, сохранять его в
файл не имеет смысла. Аналогично обстоит дело с массивами, которые задаются 
указателями. Проблемы будут и с классами, которые имеют нетривиальные операции
копирования и деструкторы или конструкторы: строго говоря, их нельзя просто 
записать в файл «побайтово» или прочитать так же. Для классов, с которыми
такие операции считаются безопасными, в C/C++ имеется специальное понятие:
POD-тип (Plain Old Data — «обычные данные»). Неформальное определение этого
понятия мы уже ввели, а формальное достаточно обширно, чтобы отправить всех
интересующихся смотреть
[стандарт языка](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3376.pdf)
по этому вопросу.

Мы хотим запретить инстанцирование шаблона с не-POD-типами и
с указателями. Для этого в C++11 были введены специальные средства:

* [`static_assert`](http://en.cppreference.com/w/cpp/language/static_assert),
* заголовочный файл `type_traits`, а именно метафункции (вычисляются на этапе
  компиляции): [`is_pod`](http://www.cplusplus.com/reference/type_traits/is_pod/)
  и [`is_pointer`](http://www.cplusplus.com/reference/type_traits/is_pointer/).

**Задача.** Добавьте в начало операций чтения/записи `static_assert` с проверкой 
того, что тип `T` является POD и не является указателем. В основной программе
проверьте, что вам не дадут записать в файл C-строку (пока что!).

## Часть 3. И всё-таки C-строки [1 балл]

Алгоритм записи в шифрованный файл C-строки и её чтения не сильно отличается
от приведённого в первой части. Однако функции `write_n_bytes` и 
`read_n_bytes` надо заменить `write_untill_null` и `read_untill_null`, которые 
пишут или читают до нулевого байта. 

Однако мы только что запретили инстанцирование шаблонов операций чтения и записи
с указателями. Чтобы разрешить его для типа `char *` мы запишем так называемую
_специализацию шаблона_. Вот как определяется специализация шаблона `operator<<`
для типа `char *`:

    template<>
    rsaed_ofile & rsaed_ofile::operator<< <char *>(char * str)
    {
        write_untill_null(str);
        return *this;
    }

Специализация шаблона функции-члена должна определяться вне класса (обычно: чуть
ниже), но при этом она остаётся функцией-членом и имеет доступ к закрытым членам
класса.

Алгоритм работы `write_untill_null` почти полностью повторяет работу 
`write_n_bytes`, только внутри следует использовать не цикл `for` из `n` шагов,
а цикл `do-while`, тело цикла почти не меняется. Учтите, что нулевой байт,
которым заканчивается C-строка, следует записывать в файл.

**Задача.** Определите специализации шаблонов функций ввода-вывода для типа 
`char *`, реализуйте функции `write_untill_null` и `read_untill_null`. В основной
программе проверьте возможность записи и последующего чтения одной C-строки.

## Дополнительная задача: контроль размера файла

В схеме с постепенным заполнением буфера непонятно, как контролировать размер
файла. Например, мы записали два `int`, в результирующий файл будет помещён один 
`ZZ`. Запишем три `int` — всё равно в файле окажется один `ZZ`. При чтении 
такого файла непонятно, когда остановиться. Для решения
этой проблемы следует контролировать количество записанных байт, а в деструкторе 
`rsaed_ofile` записывать в начало файла итоговую длину. Для этого в начале файла 
следует записать в файл `sizeof(int)` фиктивных байт, чтобы в конце поместить в 
это место итоговую длину. Для перемещения в начало файла можно использовать 
стандартную функцию
[`rewind`](http://www.cplusplus.com/reference/cstdio/rewind/).

Класс для чтения файла тоже надо несколько изменить —  с учётом того, что в 
первых `sizeof(int)` байтах указана длина файла: их нужно прочесть сразу в 
конструкторе.
Далее операция чтения должна следить за тем, чтобы общее число 
прочитанных байт не превышало эту длину. Если все байты прочитаны, то дальнейшие
вызовы операции чтения больше не должны менять правый аргумент. Кроме того, 
следует добавить преобразование объекта `rsaed_ifile` к `bool` (см. пример в 
[лекции 14](http://razykov.github.io/PL_Lections_2014-2015/lecture/14.html#typecast)
для `double`). Это преобразование проверяет достигнута ли длина файла. Такое 
преобразование позволит пользователю понять, что файл прочитан целиком.

Приведите пример записи в файл и чтения из файла с контролем длины на примере 
хранения в файле массива целых чисел.

Обратите внимание, что длина хранится незашифрованном виде: это сделано для 
простоты. Продумайте и по желанию реализуйте алгоритм хранения длины в 
зашифрованном виде вместе с остальными данными.
