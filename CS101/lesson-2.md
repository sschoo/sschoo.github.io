---
layout: defult
---

[//]: <> ( assignment id: 6833 )

## Требования к оформлению работы ##

1. При написании кода необходимо руководствоваться [правилами оформления исходных текстов программ](http://edu.mmcs.sfedu.ru/mod/resource/view.php?id=6828).
2. Каждое задание должно выполняться в _отдельном файле_.
    * В начало файла следует поместить комментарий с условием задания.
    * Все выполненные задания (набор .pas-файлов) следует заархивировать и закачать на этот сайт, используя ссылку внизу страницы.
    * Рекомендуется давать архиву _имя следующего вида_: `CT2_Ivanov` (CT — Class Task).
    * Текстовый ответ на задание должен содержать _перечисление номеров выполненных заданий_ (можно использовать сокращение «все/всё», если выполнено всё).
    * Окончательную версию решений следует отправить для получения оценки с помощью кнопки **«Отправить»** (задания в сотстоянии _«черновик» не проверяются_).

### Оценка ###

4 «грязных» балла.  
Баллы за лабораторную начисляются в конце занятия. Баллы за _частично_ выполненную лабораторную выставляются с шагом 0.5 балла. Если задача $K$ помечена текстом «**`Оценка: G`**», это означает, что за выполнение всех задач от первой до $K$-той включительно ставится $G$ баллов.

Дополнительные задания во время лабораторной не оцениваются, но они настоятельно рекомендуются к выполнению. Аналогичные задания могут встретиться в домашней работе, а также при выполнении бонусных заданий.

# Лабораторная работа #

## Замечания ##

На первой лекции вы уже узнали о таком свойстве алгоритма, как **массовость**: алгоритм должен работать со всеми _допустимыми_ входными данными и выдавать для них правильный результат. Это касается и ваших программ.

Пусть есть задача: даны две точки на числовой оси, вывести расстояние между ними. Следующая программа _не_ является решением данной задачи:

    begin
      var x, y: integer;
      read(x, y);
      writeln(x - y);
    end.

Приведённая программа работает корректно только для точек `x, y | x ≥ y` (в противном случае ответ будет отрицательным), но по условию даны произвольные точки. То есть программа не удовлетворяет условию массовости, поскольку не работает корректно _со **всеми допустимыми** входными данными_.

При выполнении заданий обращайте внимание на описание входных данных и проверяйте, что ваша программа «умеет обращаться» со всеми допустимыми значениями.

## Комментарии к теме ##

**_Используемые понятия_**: тип `integer`, операции **`div`** (вычисление частного от деления) и **`mod`** (вычисление остатка от деления), **стандартный вид числа** (напр. `123 = 1*100 + 2*10 + 3*1`).

Операция **`div`** вычисляет _целую часть_ от результата деления целых чисел (_неполное частное_). Например:
    
```{.text}
10 div  2 = 5
22 div  7 = 3
65 div 10 = 6
```

Операция **`mod`** вычисляет _остаток от деления_ одного целого числа на другое.
Если числа делятся нацело, остаток равен нулю. Например:

```{.text}
10 mod  2 = 0
22 mod  7 = 1
65 mod 10 = 5
```

Обратите внимание:
    
```{.text}
10 =  2*5 + 0 (10 div  2 = 5, 10 mod  2 = 0)
22 =  7*3 + 1 (22 div  7 = 3, 22 mod  7 = 1)
65 = 10*6 + 5 (65 div 10 = 6, 65 mod 10 = 5)
```

## Задания ##

### Стандартный вид числа, работа с разрядами ###

(@) **`{Оценка: 0.5}`** [`task01.pas`] Определить возраст человека в годах по возрасту, заданному в месяцах (например: для 65-ти месяцев это 5 _полных_ лет, для 24-х — 2 года).
    Проверьте правильность вашей программы, приведите лог работы в форме комментария.
(@) [`task02.pas`]
    *   Дано двузначное целое число. Вывести его правую и левую цифры. _Например:_
        
        ```{.text}
        35 >>> 5, 3
        90 >>> 0, 9
        ```

    *   **Проверьте**, что происходит для _отрицательных_ чисел. Например, для числа -46.

        ```{.text}
        (a) -46 >>> -6, -4 (?)
        (b) -46 >>> 6, 4
        ```

        В случае `(b)` (если `-46 >>> 6, 4`) ваше решение соответствует условию задачи — вывести *цифры* числа. Иначе нужно найти ошибку.
    *   Действительно, `-46 = 10*(-4) + (-6)`, т.е.

        ```{.text}
        -46 div 10 = -4
        -46 mod 10 = -6
        ```

        Но нас интересует не просто результат операций `div` и `mod`, а *цифры* числа. Заметим, что числа -46 и 46 состоят из одинаковых цифр.
    *   **Исправьте** программу.   
        **_Указание_**. Обратите внимание, что фактически нужно вывести цифры _модуля_ числа.
    *   Запустите программу и подайте на вход _не_ двузначное число. Что произошло? Понятен ли результат?   
        **Замечание.** Позже мы научимся выполнять проверку допустимости входных данных.
(@) **`{Оценка: 1}`** Дано двузначное целое число. Вывести сумму и произведение его цифр. Проверьте правильность вашей программы, приведите лог работы в форме комментария.
    *Пример*:

    ```{.text}
     35 >>> 8, 15
     90 >>> 9, 0
    -11 >>> 2, 1     (!) сумма и произведение цифр положительны
    ```

    **Замечание**. Каждая цифра числа понадобится дважды: при участии в вычислении суммы — в первый раз, и произведения — во второй.
    Рекомендуется использовать для цифр *вспомогательные переменные*.
(@) Дано трёхзначное целое число. Вывести все его цифры (порядок не имеет значения). Проверьте правильность вашей программы, приведите лог работы в форме комментария.
    *Пример*:

    ```{.text}
    -105 >>> 5, 0, 1
    или
    -105 >>> 1, 0, 5
    ```

(@) **`{Оценка: 1.5}`** Дано трёхзначное целое число. Вывести сумму его цифр. Убедитесь, что ваша программа корректно работает с отрицательными числами.
(@) **`{Оценка: 2}`** Даны два целых числа от 0 до 9. Пользуясь стандартным видом числа, сформируйте число, разрядами которого являются заданные цифры. *Например*:

    ```{.text}
    3, 5 >>> 35
    7, 0 >>> 70
    0, 4 >>> 4
    ```

(@) **`{Оценка: 2.5}`** Дано двузначное целое число. Поменяйте в нем местами разряды десяток и единиц.
    Проверьте правильность вашей программы, приведите лог работы в форме комментария. *Например*:

    ```{.text}
     35 >>>  53
    -10 >>> -1
    ```

    _**Указание.**_ Результирующее число должно иметь тот же знак (signum, sign), что и исходное. Воспользуйтесь справкой по математическим функциям.
(@) Дано трёхзначное целое число. Поменяйте в нем местами разряды сотен и десятков.
    Проверьте правильность вашей программы, приведите лог работы в форме комментария.
(@) **`{Оценка: 3}`** Дано трёхзначное целое число. Выполните в нем _циклический_ сдвиг разрядов влево (разряд единиц становится разрядом десятков, разряд десятков — разрядом сотен, а разряд сотен — разрядом единиц). *Например*:

    ```{.text}
     123 >>>  231
    -602 >>> -26
    ```

(@) **`{Оценка: 3.5}`** [`task10.pas`] Дано трёхзначное целое число. Сформировать новое число, каждый разряд которого меньше на единицу. Если разряд данного числа равен 0, то он должен стать равным 9 (*использовать условный оператор нельзя*).
    *Например*:

    ``` {.text}
     267 >>> 156
     601 >>> 590
     111 >>> 0
    -150 >>> -49
    ```

    **Замечание**. Обратите внимание, что для любого целого числа `d` в диапазоне `0..9` верно, что    
    $$(d + 10) \; \mathtt{mod} \; 10 = d \; \mathtt{mod} \; 10 = d$$    
    а также    
    $$({-1} + 10) \; \mathtt{mod} \; 10 = 9 \; \mathtt{mod} \; 10 = 9$$    
    Проверьте правильность вашей программы, приведите лог работы в форме комментария.

### Двоичное представление чисел ###

Используемые понятия: [битовые операции](http://ru.wikipedia.org/wiki/%D0%91%D0%B8%D1%82%D0%BE%D0%B2%D1%8B%D0%B5_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8).

К *битовым* относятся бинарные операции **`and`**, **`or`**, **`not`**, **`xor`**, **`shl`**, **`shr`**. Они производят побитовые манипуляции с операндами целого типа.
Битовые операции **`and`**, **`or`**, **`not`** и **`xor`** осуществляются следующим образом: с каждым битом (0 принимается за `False`, 1 — за `True`) производится соответствующая логическая операция.
Операции **`shl`** и **`shr`** выполняют сдвиг разрядов влево или вправо, при этом недостающие разряды дополняются нулями.
Например:

-   `00010101 and 00011001 = 00010001`{.prettyprint .lang-pascal}
-   `00010101  or 00011001 = 00011101`{.prettyprint .lang-pascal}
-   `00010101 xor 00011001 = 00001100`{.prettyprint .lang-pascal}
-   `not 00010101 = 11101010`{.prettyprint .lang-pascal}
-   `00010101 shl`{.prettyprint .lang-pascal} `3`~`10`~ ` = 10101000`{.prettyprint .lang-pascal}
-   `00010101 shr`{.prettyprint .lang-pascal} `3`~`10`~ ` = 00000010`{.prettyprint .lang-pascal}

(по умолчанию операнды и результат представлены в двоичной форме).

В решениях удобно пользоваться [функцией перевода целого положительного числа в строковое двоичное представление](http://pascalabc.net/WDE/?file=00112.pas) (в самой функции пока разбираться необязательно, её можно скопировать в свою программу).
Следует также помнить, что правила сложения и вычитания чисел «в столбик» работают вне зависимости от того, в какой системе счисления представлено (например, в двоичном представлении: `00001000 – 00000001 = 00000111`).

**Замечание.** Для упрощения работы и проверки результата используйте тип `byte` (8-битное беззнаковое целое: `0..255`) вместо `integer`. Ответ нужно выводить в двоичном и десятичном представлениях.

**Указание.** Условным оператором и циклами пользоваться нельзя!

(@) **`{Оценка: 4}`** [`task11.pas`] Дано целое число. Вывести в двоичном и десятичном видах результат операции `not` над ним. (Для сравнения удобно вывести само число в двоичном виде предварительно.)
    Убедиться, что повторное применение `not` к полученному числу даёт исходное число.
    
## Дополнительные задания ##

1.  [`extra-task-1.pas`] Даны два целых числа. Вывести в двоичном и десятичном видах результаты операций `and`, `or` и `xor` над ними. Что если исходные числа равны?
2.  [`extra-task-2.pas`] Сдвинуть число 1 влево на 1, 2, 3, 5 и 10 разрядов. Сформулировать (и записать в комментарии в программе) смысл этой операции.
3.  [`extra-task-3.pas`] Дано целое число. Обнулить его младший бит (крайний правый бит в двоичном представлении). _Использовать условный оператор нельзя_.
