---
layout: default
---

Задание состоит из пяти частей, за него можно получить 10 (чистых) баллов (по 
два балла за каждую часть). Все задания выполняются строго последовательно. Работать надо быстро.

## Часть 1. Животные

1.  [0.5 балла] В заголовочном файле `Animals.h` создайте класс `Animal` с двумя 
    чисто виртуальными функциями-членами: `say` (константная) и `move` 
    (неконстантная); в классах-наследниках они будут возвращать строки-описания 
    того, какие звуки издают животные и как они передвигаются. Там же создайте 
    три класса-открытых наследника `Animal`: `Mammal`, `Bird`, `Reptile` 
    (млекопитающие, птицы, пресмыкающиеся), с пустым телом. Там же создайте 
    открытых наследников классов `Mammal`, `Bird` и `Reptile` — конкретных видов 
    животных: двух млекопитающих, одну птицу, одно пресмыкающееся, в этих классах 
    должны быть определены функции-члены say и move. конкретные виды животных и 
    особенности их жизнедеятельности можно смотреть в Википедии.

2.  [1 балл] Добавьте в один из конкретных классов животных деструктор, в котором 
    на консоль печатается сообщение в стиле «коровы больше нет, освобождена часть 
    ресурсов». В основной программе создайте это животное в динамической памяти, 
    и запомните его в адрес в указателе на базовый класс `Animal`. Заставьте 
    животное заговорить, а затем удалите (`delete`). Сработал ли деструктор? Как 
    исправить эту проблему? 

    В деструкторе `Animal` выводите на консоль: «животное погибло: ». Сообщение после 
    двоеточия должно выводиться в деструкторах производных классов («коровы больше нет…»).
    
    Для симметрии реализуйте в конструкторе того же животного вывод сообщения о том, что
    условная корова появилась на свет. Как изменилось поведение основной программы?


3.  [2 балла] Для заселения животных в будущий зоопарк надо научиться их 
    клонировать: добавьте в класс `Animal` чисто виртуальную константную функцию 
    `clone`, возвращающую указатель на животного-клона. В конкретных классах 
    определите её реализацию, создающую и возвращающую указатель на копию текущего 
    животного (`this`) в динамической памяти:
    
        return new Cow(*this); // клонированная корова

## Часть 2. Зоопарк

1.  Создайте класс зоопарка `Zoo`, который хранит полиморфную коллекцию зверей 
    по указателям на базовый класс (в качестве конкретного класса-коллекции можно 
    выбрать `std::vector`). Создайте в классе функцию-член `addAnimal`, которая 
    добавляет некоторого животного в зоопарк (подсказка: параметр функции имеет 
    тип `Animal *`). В её реализации должно выполняться клонирование и помещение 
    адреса клона в хранящуюся в зоопарке коллекцию.

    **Замечание.** Подумайте, как можно было бы реализовать `Zoo::addAnimal` без 
    функции-члена `Animal::clone`.

2.  [1 балл] При создании клонов происходит выделение динамической памяти. Эту 
    память необходимо возвращать операционной системе вручную, используя операцию 
    `delete`. Организуйте забой животных при закрытии зоопарка (деструктор класса 
    `Zoo`).

3.  Как только вы написали нетривиальный деструктор для вашего класса, сразу 
    нужно подумать о переопределении сгенерированных автоматически конструктора 
    копий и операции копирующего присваивания. В данном случае разумным будет 
    удалить их (мы делали эту операцию для классов проекта RSAed Files — 
    вспомните как).

4.  [2 балла] Создайте функцию-член `Zoo::walk`, в которой каждое животное в 
    зоопарке издаёт звуки и передвигается. В её реализации рекомендуется 
    использовать [`for` из C++11](http://en.cppreference.com/w/cpp/language/range-for) 
    (aka `foreach`). Помните, что обращение к функциям-членам по указателям на 
    объекты принято осуществлять с помощью операции `->`. Продемонстрируйте его 
    работу в основной программе.

## Часть 3. Персональная информация о животных

Время добавить персональную информацию животным — имя и возраст. Вопрос, как 
лучше это сделать, не прост. 

Вариант 1 [плохой]. Можно было бы добавить соответствующие поля и геттеры в 
класс `Animal`. Однако общая рекомендация при создании больших иерархий классов 
состоит в том, чтобы разделять наследование интерфейса и наследование реализации.
Практическую пользу от этого мы увидим в части 4. А пока просто добавьте в 
«интерфейс» `Animal` чисто виртуальные константные функции-члены `getName` и 
`getAge`.

Вариант 2 [получше]. Вынести реализацию в отдельный класс, назовём его `Creature`, 
и добавить этот класс в иерархию каким-нибудь хитрым способом: чтобы каждый 
конкретный тип животного наследовал интерфейс от `Animal`, а реализацию части 
этого интерфейса (`getName`/`getAge`) от `Creature`. Чтобы в C++ такое решение 
корректно работало, сам `Creature` должен реализовывать интерфейс `Animal` (то 
есть наследоваться от `Animal`). То есть можно было бы составить цепочку 
наследования: 

>`Animal` ← `Creature` ← [конкретное животное]. 

Однако в нашей 
цепочке есть ещё одно звено: `Mammal`/`Bird`/`Reptile`. Вставить это звено можно 
в одно из двух мест в данной цепочке: 

1. Слева от `Creature` — тогда получится, что `Creature` одновременно и млекопитающее и 
птица и рептилия; 

2. Справа от `Creature` — мы получим 
смешение наследования интерфейса и реализации, от которого стремились уйти: классы 
конкретных животных будут наследовать от одного класса сразу и интерфейс и 
реализацию.

Удовлетворительный выход из сложившейся ситуации (которая должна казаться 
безвыходной!) — превращение `Creature` в шаблон следующего вида, чтобы получить
цепочку вида `Animal` ← `???` ← `Creature<???>` ← [конкретное животное], где
вместо `???` означает `Mammal`/`Bird`/`Reptile`.

    template<typename T>
    class Creature : public T {
        // закрытые поля name, age 
        // открытые геттеры для полей;
        // конструктор с инициализацией полей
        // (тип T никак не используется)
    };

Конкретное животное теперь должно выглядеть так:

    class Cow : public Creature<Mammal> {
        // конструктор с параметрами для вызова конструктора Creature<Mammal>
    };

1. [1 балл] Выполните реализацию `Creature` и изменение классов конкретных животных (наследование и конструкторы).

2. [2 балла] Добавьте в класс `Animal` закрытую виртуальную функцию-член `print` с одним параметром — выходным потоком; реализация этой функции должна использовать `getName` и `getAge`. Определите операцию вывода в поток для класса `Animal`, в ней нужно вызвать функцию `print`. Попробуйте распечатать с помощью данной операции вывода в поток объект какого-либо животного. 

## Часть 4. Сурикат

Довольно интересное животное — [сурикат](http://ru.wikipedia.org/wiki/%D0%A1%D1%83%D1%80%D0%B8%D0%BA%D0%B0%D1%82). О нём известно, что в разное время суток он издаёт разные звуки. Эта особенность была реализована в классе `MaverickMeerkat`: [заголовочный файл](http://mmcs.sfedu.ru/~ulysses/Edu/IT211/zoo/Meerkat.h), библиотека с реализацией функций-членов:

<div align="center">[win32@x86](http://mmcs.sfedu.ru/~ulysses/Edu/IT211/zoo/Meerkat.lib) / [win32@x86-64](http://mmcs.sfedu.ru/~ulysses/Edu/IT211/zoo/Meerkat64.lib) / [linux@x86](http://mmcs.sfedu.ru/~ulysses/Edu/IT211/zoo/libmeerkat.a) / [linux@x86-64](http://mmcs.sfedu.ru/~ulysses/Edu/IT211/zoo/libmeerkat64.a).</div>

(В классах используются 32-битные версии ОС. Под Windows библиотека компилировалась на Visual C++ 2013 и с другими версиями компилятора работать не будет.) Заметьте, что если сохранить файл библиотеки и заголовочный файл в корне проекта, то для подключения библиотеки будет достаточно лишь указать опцию «Компоновщик» — «Ввод» в настройках проекта.

Класс проектировался без учёта нашей иерархии животных. Добавьте в иерархию класс `Meerkat` (сурикат — млекопитающее, а значит, наследует `Mammal`), который имеет поле типа `MaverickMeerkat` и реализует все необходимые функции-члены с помощью обращений к этому полю. Поиграйтесь с сурикатом в основной программе.

**Замечание 1.** Послушайте, какие звуки издаёт сурикат с полуночи до 8 утра (запустите программу в это время суток).

**Замечание 2.** Наконец можно дать ответ на вопрос, зачем разделяют наследование интерфейса и наследование реализации. При желании добавить в иерархию новый класс, имеющий свою особенную реализацию, это можно сделать достаточно легко и без дополнительных расходов. Если бы в классе `Animal` (или `Mammal`, как в варианте `Animal` ← `Creature` ← `Mammal` ← [конкретное животное]) были определены поля для имени и возраста, то внутри класса `Meerkat` происходило бы дублирование: одна пара полей досталась от `Animal`, вторая — от `MaverickMeerkat`.

## Часть 5. Производство зоопарков

1.  [0.5 балла] Для массового производства зоопарков и заполнения их животными создайте два 
    базовых класса, `ZooCreator` и `AnimalCreator` с пустыми открытыми виртуальными
    деструкторами. (Это можно сделать в одном заголовочном файле, например, 
    `ZooCreation.h`.) В первом классе объявите чисто виртуальную функцию

        Zoo *    create()
    
    во втором — чисто виртуальную функцию

        Animal * create(string const & spec, string const & name, int age)
    
    где `spec` — это строковое описание вида конкретного животного.
    
    **Замечание.** Функции с именами `create` и `clone` часто используются для 
    размещения объектов в динамической памяти. В этом случае к ним нужно добавлять
    комментарии, настойчиво требующие от клиента этих функций освобождения этой 
    памяти с помощью `delete`. Добавьте такие комментарии там, где это необходимо.
    
2.  [1 балл] 
    Создайте открытого наследника `AnimalCreator` — класс `SimpleAnimalCreator`, 
    который в основе алгоритма создания животного использует длинную цепочку 
    `if`'ов по параметру `spec`. В основной программе попробуйте создать и использовать 
    полиморфно его и создаваемых им животных. Не забывайте освобождать динамическую 
    память.

3.  [2 балла] 
    Создайте открытого наследника `ZooCreator` — класс `StreamZooCreator`, 
    заполняющий зоопарк на основе информации о животных, которая приходит из 
    переданного потока, с помощью переданного создателя животных (`AnimalCreator`).
    У класса должно быть два поля типов `istream &` и `AnimalCreator *`, которые
    инициализируются в конструкторе. Функция `create` в цикле считывает из потока 
    информацию, необходимую для создания животного, и вызывает функцию 
    `AnimalCreator::create`. Результат последней должен передаваться в 
    `Zoo::addAnimal` для создаваемого зоопарка и, далее, удаляться (`delete`).

    Попробуйте создать зоопарк с помощью потока. Для простоты — строкового:

        istringstream iss("cow mumka 1 cow zorka 2");
        SimpleAnimalCreator sac;
        StreamZooCreator zc(iss, &amp;sac);
        Zoo * z = zc.create();
        zoo->walk();
        delete zoo;

## Дополнительные задачи

1.  Создайте открытого наследника `ZooCreator` — класс `RandomZooCreator`, заполняющий зоопарк случайными животными со случайными данными в количестве, указанном в соответствующем поле класса (инициализируется в конструкторе). Как и прежде, используется `AnimalCreator`. Базу имён для генерации случайных имён загрузите при создании объекта класса из файла [pet-names.txt](http://mmcs.sfedu.ru/%7Eulysses/Edu/IT211/pet-names.txt).

2. Реализуйте наследника AnimalCreator — класс `PrototypedAnimalCreator`, который имеет поле-отображение `std::map<std::string, Animal *> protoanimals`. (Шаблон класса map находится в заголовочном файле map.) Для каждого строкового описания животного он хранит экземпляр этого животного в динамической памяти. При вызове `create` по параметру `spec` из `protoanimals` достаётся соответствующее животное, ему задаются имя и возраст, и, наконец, в качестве результата возвращается его клон. На данный момент в программе нет возможности изменения имени и возраста животного. Добавьте в класс `Animal` закрытые сеттеры этих полей, объявите класс `PrototypedAnimalCreator` другом `Animal`. Реализация сеттеров выполняется каждом конкретном классе животного отдельно. Для этого потребуется добавить защищённые сеттеры в класс Creature. (Оцените затраты на изменение интерфейса...)
